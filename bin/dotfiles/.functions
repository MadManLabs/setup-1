#!/usr/bin/env bash

# functions
#
# useful utility functions
# --------

# asks the user to approve or deny something
#
# params:
#   prompt - what to ask the user to approve
#
# usage: prompt_user prompt
#
# returns:
#   0 - if reply is Y or y
#   1 - if reply is anything else
#
function prompt_user() {
    if [ -z "$1" ]; then
        echo "usage: ${FUNCNAME[0]} prompt"
        return 1
    fi

    read -r -e -p "$1 "
    echo ""

    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
        return 0
    fi

    return 1
}

# list go packages
#
# params:
#   package - package name to search for
#
# usage: golist [package]
#
function golist() {
    pkgs=$(go list ... | sed 's#.*/##')

    if [[ -z "$1" ]]; then
        echo "${pkgs[@]}"
    else
        echo "${pkgs[@]}" | /usr/bin/env grep "$1"
    fi
}

# upgrade everything on computer
#   1. macOS
#   2. homebrew
#   3. vim
#   4. python
#   5. ruby
#   6. node.js
#
# usage: update
#
function update() {
    cd || exit

    # macOS

    if prompt_user "update macOS? (y/n)"; then
        softwareupdate --install --all
    fi

    # homebrew

    if command -v brew &> /dev/null; then
        echo "updating brew packages..."
        brew update

        if prompt_user "update all packages? (y/n)"; then
            brew upgrade
        elif prompt_user "approve package updates individually? (y/n)"; then
            for pkg in $(brew outdated --quiet); do
                if prompt_user "update $pkg? (y/n)"; then
                    brew upgrade "$pkg"
                fi
            done
        fi

        echo "pruning dead symlinks..."
        brew prune

        echo "cleaning up..."
        brew cleanup
    fi

    # vim

    if command -v vim &> /dev/null; then
        echo "updating vim packages..."

        if prompt_user "update vim packages? (y/n)"; then
            if [ -d ~/.vim/bundle ]; then
                cd ~/.vim/bundle || exit

                for d in *; do
                    cd "$d" || exit
                    git pull
                    cd .. || exit
                done

                cd || exit
            fi
        fi
    fi

    # python

    if command -v pip &> /dev/null; then
        echo "updating python packages..."

        if prompt_user "update pip? (y/n)"; then
            pip install --upgrade pip
        fi

        PYTHON_PACKAGES="$(pip freeze --local | grep -v ^-e | cut -d = -f 1)"

        if [ ! -z "$PYTHON_PACKAGES" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $PYTHON_PACKAGES; do
                    pip install --upgrade "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)"; then
                for pkg in $PYTHON_PACKAGES; do
                    if prompt_user "update $pkg? (y/n)"; then
                        pip install --upgrade "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    # ruby

    if command -v gem &> /dev/null; then
        echo "updating ruby gems..."

        RUBY_GEMS="$(gem outdated | cut -d ' ' -f 1)"

        if [ ! -z "$RUBY_GEMS" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $RUBY_GEMS; do
                    gem update "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)" ; then
                for pkg in $RUBY_GEMS; do
                    if prompt_user "update $pkg? (y/n)"; then
                        gem update "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    # node.js

    if command -v npm &> /dev/null; then
        echo "updating npm packages..."

        NPM_PACKAGES="$(npm outdated -g --parseable --depth 0 | cut -d : -f 4)"

        if [ ! -z "$NPM_PACKAGES" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $NPM_PACKAGES; do
                    npm install -g "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)"; then
                for pkg in $NPM_PACKAGES; do
                    if prompt_user "update $pkg? (y/n)"; then
                        npm install -g "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi
}

# set up default tmux layout
#
# params:
#   name - session name
#
# usage: mux [name]
#
function mux() {
    if [[ -z "$1" ]]; then
        TMUX_SESSION="work"
    else
        TMUX_SESSION="$1"
    fi

    tmux start-server
    tmux new-session -s "$TMUX_SESSION" -d
    tmux split-window -h
    tmux split-window -v
    tmux new-window -t "$TMUX_SESSION:1" vim
    tmux new-window -t "$TMUX_SESSION:2"
    tmux attach-session -t "$TMUX_SESSION:0"
}

# converts quicktime screen recording to a gif
#
# params:
#   infile - input file (.mov)
#   outfile - output file (.gif)
#
# usage: mov2gif infile outfile
#
function mov2gif() {
    usage="usage: mov2gif input output"

    if [ -z "$1" ] || [ -z "$2" ]; then
        echo "$usage"
        return 1
    elif command -v ffmpeg &> /dev/null && command -v gifsicle &> /dev/null; then
        infile="$1"
        outfile="$2"

        if [ -f "$infile" ]; then
            ffmpeg -hide_banner -loglevel quiet -i "$infile" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$outfile"
        else
            echo "error: input is not a file"
            return 1
        fi
    else
        echo "error: ffmpeg and gifsicle not installed"
        return 1
    fi
}

# starts a python server, with optional port argument
#
# params:
#   port - valid port to run server from
#
# usage: server [port]
#
function server() {
    python -m SimpleHTTPServer "${1:-8080}"
}
