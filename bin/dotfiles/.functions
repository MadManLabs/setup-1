#!/usr/bin/env bash

# functions
#
# useful utility functions
# --------

red="\e[0;31m"
green="\e[0;32m"
reset="\e[0m"

# set up a new git repo (made for github and bitbucket)
#
# uses MDL style linter for markdown, copies .gitignore, .gitattributes
# files from home directory, creates README.md and LICENSE files. for
# github repositories, create a .github folder with templates.
#
# params:
#   host - github or bitbucket
#
# usage: repo host
#
# returns:
#   0 - everything worked
#   1 - something went wrong
function repo() {
    # init the repo

    if git --version &> /dev/null; then
        git init
    else
        return 1
    fi

    # create README.md and LICENSE files

    dir="$(basename "$PWD")"
    echo -e "# ${dir}\n---" > README.md
    touch LICENSE

    # copy or create .gitignore and .gitattributes files

    if [ -f ~/.gitignore ]; then
        cp ~/.gitignore .
    else
        touch .gitignore
    fi

    if [ -f ~/.gitattributes ]; then
        cp ~/.gitattributes .
    else
        touch .gitattributes
    fi

    # copy or create .mdlrc and .mdl.style.rb files

    if [ -f ~/.mdlrc ]; then
        cp ~/.mdlrc .
    else
        touch .mdlrc
    fi

    if [ -f ~/.mdl.style.rb ]; then
        cp ~/.mdl.style.rb .
    else
        touch .mdl.style.rb
    fi

    # misc. files

    touch CHANGELOG.md
    touch .editorconfig

    # .github template files

    if [ "$1" == "github" ]; then
        git tpl
    elif [ "$1" == "bitbucket" ]; then
        touch CONTRIBUTING.md
    fi
}

# asks the user to approve or deny something
#
# params:
#   prompt - what to ask the user to approve
#
# usage: prompt_user prompt
#
# returns:
#   0 - if reply is Y or y
#   1 - if reply is anything else
#
function prompt_user() {
    if [ -z "$1" ]; then
        echo "usage: ${FUNCNAME[0]} prompt"
        return 1
    fi

    read -r -e -p "$1 "
    echo ""

    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
        return 0
    fi

    return 1
}

# list go packages
#
# params:
#   package - package name to search for
#
# usage: golist [package]
#
function golist() {
    pkgs=$(go list ... | sed 's#.*/##')

    if [[ -z "$1" ]]; then
        echo "${pkgs[@]}"
    else
        echo "${pkgs[@]}" | /usr/bin/env grep "$1"
    fi
}

# upgrade everything on computer
#   1. macOS
#   2. homebrew
#   3. vim
#   4. python
#   5. ruby
#   6. node.js
#
# usage: update
#
function update() {
    cd || exit

    # macOS

    if prompt_user "update macOS? (y/n)"; then
        softwareupdate --install --all
    fi

    # homebrew

    if command -v brew &> /dev/null; then
        echo "updating brew packages..."
        brew update

        if prompt_user "update all packages? (y/n)"; then
            brew upgrade
        elif prompt_user "approve package updates individually? (y/n)"; then
            for pkg in $(brew outdated --quiet); do
                if prompt_user "update $pkg? (y/n)"; then
                    brew upgrade "$pkg"
                fi
            done
        fi

        echo "pruning dead symlinks..."
        brew prune

        echo "cleaning up..."
        brew cleanup
    fi

    # vim

    if command -v vim &> /dev/null; then
        echo "updating vim packages..."

        if prompt_user "update vim packages? (y/n)"; then
            if [ -d ~/.vim/bundle ]; then
                cd ~/.vim/bundle || exit

                for d in *; do
                    cd "$d" || exit
                    git pull
                    cd .. || exit
                done

                cd || exit
            fi
        fi
    fi

    # python 2

    if command -v pip &> /dev/null; then
        echo "updating python 2 packages..."

        if prompt_user "update pip? (y/n)"; then
            pip install --upgrade pip
        fi

        PYTHON_PACKAGES="$(pip freeze --local | grep -v ^-e | cut -d = -f 1)"

        if [ ! -z "$PYTHON_PACKAGES" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $PYTHON_PACKAGES; do
                    pip install --upgrade "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)"; then
                for pkg in $PYTHON_PACKAGES; do
                    if prompt_user "update $pkg? (y/n)"; then
                        pip install --upgrade "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    # python 3

    if command -v pip3 &> /dev/null; then
        echo "updating python 3 packages..."

        if prompt_user "update pip? (y/n)"; then
            pip3 install --upgrade pip
        fi

        PYTHON3_PACKAGES="$(pip3 freeze --local | grep -v ^-e | cut -d = -f 1)"

        if [ ! -z "$PYTHON3_PACKAGES" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $PYTHON3_PACKAGES; do
                    pip3 install --upgrade "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)"; then
                for pkg in $PYTHON3_PACKAGES; do
                    if prompt_user "update $pkg? (y/n)"; then
                        pip3 install --upgrade "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    # ruby

    if command -v gem &> /dev/null; then
        echo "updating ruby gems..."

        RUBY_GEMS="$(gem outdated | cut -d ' ' -f 1)"

        if [ ! -z "$RUBY_GEMS" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $RUBY_GEMS; do
                    gem update "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)" ; then
                for pkg in $RUBY_GEMS; do
                    if prompt_user "update $pkg? (y/n)"; then
                        gem update "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    # node.js

    if command -v npm &> /dev/null; then
        echo "updating npm packages..."

        NPM_PACKAGES="$(npm outdated -g --parseable --depth 0 | cut -d : -f 4)"

        if [ ! -z "$NPM_PACKAGES" ]; then
            if prompt_user "update all packages? (y/n)"; then
                for pkg in $NPM_PACKAGES; do
                    npm install -g "$pkg"
                done
            elif prompt_user "approve package updates individually? (y/n)"; then
                for pkg in $NPM_PACKAGES; do
                    if prompt_user "update $pkg? (y/n)"; then
                        npm install -g "$pkg"
                    fi
                done
            fi
        else
            echo "nothing to update"
        fi
    fi

    echo -e "${green}done: software updated${reset}"
}

# set up default tmux layout
#
# params:
#   name - session name
#
# usage: mux [name]
#
function mux() {
    stats="top -o mem -O cpu -stats pid,command,cpu,mem,time,state,user"

    if [[ -z "$1" ]]; then
        TMUX_SESSION="work"
    else
        TMUX_SESSION="$1"
    fi

    tmux start-server

    if tmux has-session -t "$TMUX_SESSION" &> /dev/null; then
        echo -e "${red}fatal: session '$TMUX_SESSION' already exists${reset}"
        return 1
    fi

    # first window has 3 panes
    tmux new-session -s "$TMUX_SESSION" -n "main" -d
    tmux split-window -h -t "$TMUX_SESSION:0"
    tmux split-window -v -t "$TMUX_SESSION:0"

    # set up vim in full screen
    tmux new-window -t "$TMUX_SESSION:1" -n "vim"
    tmux send-keys -t "$TMUX_SESSION:1" vim C-m

    # two panes split left and right
    tmux new-window -t "$TMUX_SESSION:2" -n "stats"
    tmux split-window -h -t "$TMUX_SESSION:2"
    tmux send-keys -t "$TMUX_SESSION:2.1" "$stats" C-m

    # set up 4 equal panes
    tmux new-window -t "$TMUX_SESSION:3" -n "misc"
    tmux split-window -h -t "$TMUX_SESSION:3"
    tmux split-window -v -t "$TMUX_SESSION:3.0"
    tmux split-window -v -t "$TMUX_SESSION:3.2"

    # attach to first pane of first window
    tmux attach-session -t "$TMUX_SESSION:0.0"
}

# converts quicktime screen recording to a gif
#
# params:
#   infile - input file (.mov)
#   outfile - output file (.gif)
#
# usage: mov2gif infile outfile
#
function mov2gif() {
    usage="usage: mov2gif input output"

    if [ -z "$1" ] || [ -z "$2" ]; then
        echo "$usage"
        return 1
    elif command -v ffmpeg &> /dev/null && command -v gifsicle &> /dev/null; then
        infile="$1"
        outfile="$2"

        if [ -f "$infile" ]; then
            ffmpeg -hide_banner -loglevel quiet -i "$infile" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$outfile"
        else
            echo "error: input is not a file"
            return 1
        fi
    else
        echo "error: ffmpeg and gifsicle not installed"
        return 1
    fi
}

# starts a python server, with optional port argument
#
# params:
#   port - valid port to run server from
#
# usage: server [port]
#
function server() {
    python -m SimpleHTTPServer "${1:-8080}"
}
